# 8장

## 8-1. 함수 옮기기

- **모듈성**이란 프로그램의 **어딘가를 수정**하려 할 때 해당 기능과 깊이 **관련된 작은 일부만 이해**해도 **가능**하게 해주는 능력
- **객체 지향** 프로그램의 핵심 **모듈화 컨텍스트**는 **클래스**
- 객체 지향 언어에서는 함수를 옮길때 **다형 메서드**인지도 확인해야함
- **중첩 함수**를 사용하다보면 **숨겨진 데이터끼리 상호 의존**하기가 아주 쉬우니 중첩함수는 **되도록 만들지 말자**

## 8-2. 필드 옮기기

- **함수**에 항상 함께 **전달되는 데이터**들은 상호 관계가 명확하게 드러나도록 **한 레코드**에 담는게 가장 좋음. 따라서 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함게 넘기고 있다면 데이터 위치를 옮겨야 함.
- 구조체 **여러 개에 정의**된 **똑같은 필드**들을 **갱신**해야한다면 **한번만 갱신**해도 되는 **다른 위치로 옮기**라는 신호
- 사용하는 패턴 때문에 데이터를 옮길 수 없다면, 사용 패턴을 먼저 리팩터링 한다음에 필드를 옮김

## 8-3. 문장을 함수로 옮기기

- 특정 함수 호출 앞뒤에서 똑같은 코드가 추가로 실행된다면, 해당 부분을 호출되는 함수 안으로 옮김

## 8-4. 문장을 호출한 곳으로 옮기기

- 반대 리팩터링: 8-3. 문장을 함수로 옮기기
- 여러 곳에서 사용하던 기능이 일부 호출자에게 다르게 동작하도록 바뀌어야한다면 달라진 동작을 함수에서 꺼내야함

## 8-5. 인라인 코드를 함수 호출로 바꾸기

```javascript
// 전
let appliesToMass = false;
for(const s of states) {
  if ( s === "MA" ) appliesToMass = true;
}

// 후
appliesToMass = states.includes("MA");
```

- 특히 라이브러리가 제공하는 함수로 대체할 수 있다면 훨씬 좋음. 함수 본문을 작성할 필요조차 없어지기 때문

## 8-6. 문장 슬라이드하기

- **관련 코드**들이 **가까이** 모여있으면 이해하기 더 쉬움

- 모든 변수 선언을 함수 첫머리에 모아두는 사람도 있지만, 저자는 변수를 **처음 사용할 때 선언**하는 스타일을 선호

- 관련 코드들을 명확히 구분되는 함수로 추출하는게, 그저 문장들을 한데로 모으는 것보다 나은 분리법. 하지만 애초에 코드들이 모여있지 않으면 함수 추출을 수행할 수 없음

- **부수 효과**가 있는 코드를 **슬라이드**하거나, 부수 효과가 있는 코드를 건너 뛰어야한다면 **훨씬 신중**해야함

  예를 들어 아래의 if 문은 코드 끝으로 슬라이드 할 수 없음. 왜냐하면 charge 쪽의 변수가 상태를 수정한 discount 를 참조하고 있기 때문.

  ```javascript
  let discount = discountableUnits * pricePlan.discountFactor;
  if (ordier.isRepeat) discount += 20;
  charge = charge - discount;
  ```

## 8-7. 반복문 쪼개기

```javascript
// 전
let averageAge = 0;
let totalSalary = 0;
for (const p of people) {
  avaerageAge += p.age;
  totalSalary += p.salary;
}
avergeAge = averageAge / people.length

// 후
let totalSalary = 0;
for (const p of people) {
  totalSalary += p.salary;
}

let averageAge = 0;
for (const p of people) {
  avaerageAge += p.age;
}
avergeAge = averageAge / people.length
```

- 두 일을 **한꺼번에 처리**할 수 있기 때문에 **종종 반복문 하나에서 두가지 일**을 수행.

- 하지만 이렇게 하면 **반복문을 수정**해야 할 때마다 **두가지 일 모두를 잘 이해하고 진행**해야함. 

- 반대로 각각의 반복문으로 **분리**해두면 수정할 동작 **하나만 이해**하면 됨

- 반복문을 쪼개면 구조체 등을 반환하거나 하는 대신, **하나의 값만 반환** 가능

- **반복문을 두번 실행**해야하므로 이 리팩터링을 **불편**해하는 프로그래머도 많지만, **리팩터링과 최적화를 구분**해야함.

  **최적화**는 코드를 **깔끔히 정리한 이후**에 수행. 반복문을 두번 실행하는게 병목이라는게 밝혀지면 그때 다시 **하나로 합치는건 쉬움**

  하지만 심지어 긴 리스트를 반복하더라도 **병목**으로 이어지는 경우는 **매우 드물고**, 오히려 반복문 쪼개기가 다른 **더 강력한 최적화**를 적용할 수 있는 길을 열어주기도 함

## 8-8. 반복문을 파이프라인으로 바꾸기

- 대표적인 연산으로는 map, filter 등이 있음
- 논리를 파이프라인으로 표현하면 이해하기 훨씬 쉬워짐. 객체가 파이프라인을 따라 흐르며 어떻게 처리되는지 읽을 수 있기 때문

## 8-9. 죽은 코드 제거하기

- 코드가 더 이상 사용되지 않게 됐다면 제거
- 다시 필요해질 수도 있지 않을까? 하고 걱정하지 않아도 됨. 우리에겐 버전 관리 시스템이 있기 때문에 다시 필요하면 되돌리면 됨.

## 나의 생각

- "8-1. 함수 옮기기"에서 중첩 함수를 지양하자고 되어있는데 동의 함. 근데 2장 이런데서는 중첩 함수 엄청 썼지 않나? 흠냐리
- "8-7. 반복문 쪼개기"에서 반복문을 여러번 실행해야하므로 이 리팩터링을 불편해하는 프로그래머도 많다고 했을때 뜨끔쓰. 하지만 리팩터링과 최적화를 구분하고, 우선 코드를 깔끔하게 만든 후에 최적화하라고 되어있어서 납득 갔음
