# 4장

## 중요 내용

- **테스트가 성공**했는지 확인하려면 **의도한 결과**와 **테스트 결과**가 같은지만 **비교**하면 됨 -> 성공하면 화면에 "**OK**" 출력 -> 모든 테스트를 완전히 자동화하고 **그 결과까지 스스로 검사**하는 **자가 테스트 소프트웨어** 탄생

- **회귀 버그** - 잘 **작동하던 기능**에서 **문제**가 생기는 현상. 일반적으로 프로그램을 변경하는 중 뜻하지 않게 발생

- **회귀 테스트** - 잘 **작동하던 기능**이 **여전히 잘 작동**하는지 확인하는 **테스트**

- 테스트를 작성하기 가장 **좋은 시점**은 **프로그래밍을 시작하기 전** -> TDD

  - 테스트를 작성하다보면 **기능 추가를 위해 무엇이 필요**한지 고민하게 됨
  - **구현보다 인터페이스**에 집중하게 됨.
  - 코딩이 **완료**되는 **시점** 판단 가능 == 테스트를 **모두 통과**한 시점

- 테스트가 갖춰지지 않은 코드를 **리팩터링**할 때는, 바로 리팩터링하지 않고 **먼저** 자가 **테스트 코드**부터 작성

- 테스트는 **위험 요인을 중심**으로 작성해야함. 테스트의 목적은 어디까지나 **현재 혹은 향후에 발생하는 버그**를 찾는데 있음. 따라서 단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요 없음. 테스트를 너무 **많이** 만들다 보면 오히려 **필요한 테스트를 놓치**기 쉬움.

- 완벽하게 만드느라 테스트를 수행하지 못하느니, **불완전한 테스트라도 작성**해 실행하는게 낫다

- 저자는 아래와 같이 **픽스처를 바깥 범위로 끌어내는 방법 사용하지 않**음.

  중복 코드를 제거하기 위한 일시적인 효과는 있겠지만, 테스트 관련 버그 중 가장 지저분한 유영인 '**테스트끼리 상호작용하게 하는 공유 픽스처**'를 생성하는 원인이 됨. 나중에 이 공유 객체의 값을 **수정**하면 이 픽스처를 사용하는 또 **다른 테스트가 실패**할 수 있음. 즉, 테스트를 실행하는 **순서에 따라 결과가 달라**질 수 있음. 이렇게 되면 버그 잡기 어렵고, 오래 걸림. 더 심하면 테스트 자체를 믿지 못하게 됨. 

  ```javascript
  describe('province', () => {
    const asia = new Province(sampleProvince()); // 이렇게 하면 안됨
   
    it('shortfall', function() {
      expect(asia.shortfall).equal(5)
    })
  
    it('profit', () => {
      expect(asia.profit).equal(230)
    })
  })
  ```

- 위의 방식 대신 **`beforeEach`** 를 사용해 각 **테스트 바로 전에 실행**되어 **픽스처를 초기화** 함. 그럼 **모든 테스트**는 **자신만의 새로운 asia** 를 사용하게 됨. 이처럼 개별 테스트를 실행할 때 마다 픽스처를 새로 만들면 **모든 테스트를 독립적으로 구성**할 수 있음.

  ```javascript
  describe('province', () => {
    let asia;
    
    beforeEach(function(){
      asia = new Province(sampleProvince());
    })
   
    it('shortfall', function() {
      expect(asia.shortfall).equal(5)
    })
  
    it('profit', () => {
      expect(asia.profit).equal(230)
    })
  })
  ```

- 매번 픽스처를 생성하느라 테스트가 눈에 띄게 **느려지는 일**은 거의 **없음**. 정말 **문제**가 될 때는 **공유 픽스처**를 사용하기도 하지만, 이럴때는 **어떠한 테스트도 픽스처 값을 변경하지 못하**도록 주의. 

- 테스트마다 **beforeEach** 가 실행된다면, 그냥 그 **코드를 it 안으로** 넣으면 되지 않냐? -> 테스트들이 모두 **똑같은 픽스처에 기초하여 검증**을 수행하기를 바람. **beforeEach** 블록의 등장은 **표준 픽스처를 사용**한다는 사실을 알려줌. 그러면 코드를 읽는 이들은 해당 **describe 블록 안의 모든 테스트**가 **똑같은 기준 데이터로부터 시작**한다는 사실을 쉽게 알 수 있음.

- '**설정**'한 **표준 픽스처**를 취해서, **테스트**를 '**수행**'하고, 이 픽스처가 일을 **기대한 대로 처리**했는지 '**검증**'함. 이 세가지 단계가 한 테스트 안에 모두 담겨있을 수도 있고, 초기 준비 작업 중 공통되는 부분을 beforeEach 와 같은 표준 설정 루틴에 모아서 처리하기도 함.

  이 패턴을 아래와 같은 이름으로 부름

  - 설정(setup) - 실행(exercise) - 검증(verify)
  - 조건(given) - 발생(when) - 결과(then)
  - 준비(arrange) - 수행(act) - 단언(assert)

- 해체(**teardown**) 또는 청소(cleanup) 이라고 하는 **네 번째 단계**도 있는데 명시적으로 언급하지 않는 경우가 많음. 해체 단계에서는 **픽스처를 제거**해서 테스트들이 **서로 영향 주지 못하게** 막음.

  설정을 모두 beforeEach 에서 하면 테스트들 사이에 걸친 픽스처를 테스트 프레임워크가 알아서 해제해주기 때문에 굳이 단계를 나눌 필요는 없음. 하지만 생성에 시간이 걸려서 여러 테스트가 **공유해야하는 픽스처** 등의 경우 해체를 **명시적으로 수행**해야 함.

- **it 구문 하나**당 **검증도 하나**씩만 하는게 좋음. 앞쪽 검증을 통과하지 못하면 나머지 검증은 실행해보지 못하고 테스트가 실패하는데, 그러면 실패 원인을 파악하는 데 유용한 정보를 놓치기 쉽기 때문.

- **단위 테스트**란 **코드의 작은 영역만을 대상**으로 빠르게 실행되도록 설계된 테스트. 단위 테스트는 자가 테스트 코드의 핵심이자, 자가 테스트 시스템은 대부분 단위 테스트가 차지

  물론 컴포넌트 사이의 상호작용에 집중하는 테스트나, 소프트웨어의 다양한 계층의 연동을 검사하는 테스트, 성능 문제를 다루는 테스트 등 다양한 유형이 테스트가 있음.

- **버그 리포트**를 받으면 가장 먼저 그 **버그를 드러내는 단위테스트** 부터 작성하는 습관을 들이자
- 테스트 스위트가 **충분**한지를 **평가**하는 기준은 **주관적**. 테스트 코드를 통해 리팩터링에서 생겨난 버그가 하나도 없다고 확신할 수 있다면 충분히 좋은 테스트 스위트.
- 테스트를 너무 많이 작성해서 개발 속도가 느려질 경우도 있지만, 보통 너무 많은 경우보다는 **너무 적은 경우가 훨씬 훨씬 많**음.

## swift 용 예시 코드
[Chapter4](https://github.com/sujinnaljin/Refactoring/tree/main/Chapter4)

## 나의 생각

- 컨퍼런스 가는 **비행기에서** 스몰토크 버전 단위 테스트 프레임워크를 자바로 포팅한게 **JUnit** 이라고,,??? 역시 천재들,, 재수 없어,,!!

