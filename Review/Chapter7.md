# 7장

## 7-1. 레코드 캡슐화 하기

```javascript
//전
organization = {name: "naljin", country: "KR"};

//후
class Organization {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }
    
  get name() {return this._name;}
  set name(arg) {this._name = arg;}
  get country() {return this._country}
  set country(arg) {this._country = arg;}
}
```

- 단순한 레코드는 계산해서 얻을 수 있는 값과, 그렇지 않은 값을 명확히 구분해 저장해야하는 점이 번거롭다고 함. 이 때문에 가변 데이터를 저장하는 용도로는 레코드 보다 객체를 선호한다고. (🤔 뭔말임?)

## 7-2. 컬렉션 캡슐화하기

- 저자는 **가변 데이터**를 모두 **캡슐화**하는 편. 그러면 **데이터 구조가 언제 어떻게 수정되는지 파악**하기 쉬워서, 필요한 시점에 데이터 구조를 변경하기도 쉬워지기 때문
- 그런데 collection 에 대한 getter 가 **collection 자체를 반환**한다면, **예기치 못하게** 컬렉션들의 원소들이 **변경**되고 결국 **오류**를 초래할 수 있음
- 따라서 **collection getter** 가 **원본 컬렉션을 반환하지 않게** 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는게 나음
- 저자의 경험에 따르면 **컬렉션**에 대해서는 어느 정도 강박증을 갖고 불필요한 **복제본을 만드**는 편이, 예상치 못한 오류를 디버깅하는 것 보다 낫다고.

## 7-3. 기본형을 객체로 바꾸기

- 단순히 **출력 이상의 기능**이 필요해지는 순간 그 데이터를 표현하는 **전용 클래스** 정의

- **시작**은 **기본형 데이터를 단순히 감싼 것**과 큰 차이가 없기 때문에 **효과가 미미**

- 하지만, 나중에 **특별한 동작**이 필요해지면 **해당 클래스에 추가**하면 되니 프로그램이 **커질수록 점점 유용한 도구**가 됨 

  ex. 전화번호 문자열 표현 -> 포매팅이나 지역 코드 추출 등의 동작이 추가로 필요

- 초보에게는 직관에 어긋나 보일 수 있지만, 시니어들은 여러가지 리팩터링 중에서도 가장 유용한 것으로 꼽음

## 7-4. 임시 변수를 질의 함수로 바꾸기

```javascript
// 전
const basePrice = this._quantity * this._itemPrice;

// 후
get bssePrice() { this._quantity * this._itemPrice; }
```

- 긴 함수의 한 부분을 **별도 함수로 추출**하고자 할 때 먼저 **변수들을 각각의 함수**로 만들면, **추출한 함수에 변수를 따로 전달할 필요가 없어지**기 때문에 일이 수월해진다고 함 (🤔 뭔말임? 222)
- 변수 대신 **함수**로 만들어두면 비슷한 계산을 수행하는 **다른 함수에도 사용**할 수 있어 코드 **중복이 줄어**듦

## 7-5. 클래스 추출하기

- 클래스는 **소수의 주어진 역할**만 처리해야함
- **메서드**와 **데이터**가 너무 **많은 클래스**는 이해하기 어려우니 적절히 **분리**해야 함
- 일부 데이터와 메서드를 **따로 묶을 수 있다**면 **분리**
- **함께 변경**되는 일이 많거나, **서로 의존**하는 데이터들도 **분리**
- 특정 데이터나 메서드 **일부를 제거**해도 다른 필드나 메서드들이 논리적으로 **문제가 없으면 분리**할 수 있다는 뜻
- 작은 일부 기능만을 위해 서브클래스를 만들거나, 확장해야 할 기능이 무엇이냐에 따라 서브클래스를 만드는 방식도 달라진다면 클래스를 나눠야한다는 신호

## 7-6. 클래스 인라인하기

- **반대** 리팩터링 : **클래스 추출**하기 (7-5)
- 클래스에 **남은 역할**이 거의 **없을때**, 해당 클래스를 **가장 많이 사용**하는 클래스로 **흡수**시키기
- 두 클래스의 기능을 지금과 다르게 배분하고 싶을때도 클래스를 먼저 인라인해서 하나로 합친 다음, 새로운 클래스로 추출.

## 7-7. 위임 숨기기

```javascript
// 전
manager = aPerson.department.manager;

// 후
manager = aPerson.manager;
class Person {
  get manager() { return this.department.manager; }
}
```

- 위임 메서드를 만들어서 위임 객체를 숨김
- 그러면 기능을 제공하는 쪽의 **위임 객체가 수정**되더라도, **사용하는 쪽**에서는 아무런 **영향을 받지 않**음

## 7-8. 중개자 제거하기

- **반대** 리팩터링 : **중개자 제거**하기 (7-7)
- 7-7 의 위임 숨기기 기법을 사용하면, 사용하는 쪽에서 **위임 객체의 또 다른 기능**을 사용하고 싶을때마다 기능을 제공하는 쪽에 **위임 메서드를 추가**해야 함. 기능을 제공하는 쪽에서는 단순한 위임 메서드들이 점점 많아지고, 그저 **중개자 역할로 전락**할 수 있음. 이럴때는 차라리 사용하는 쪽에서 **위임 객체를 직접 호출**하는게 나을 수 있음
- 위임 숨기기(7-7)와 중개자 제거하기를 **적당히 섞어도** 됨. 둘 중 하나를 반드시 해야할 필요 없이 **상황에 맞게 처리**하면 되고, 합리적인 사람이라면 어떻게 해야 가장 효과적인지 판단할 수 있을 것.

## 7-9. 알고리즘 교체하기

- 문제를 더 확실히 이해하고 훨씬 **쉽게 해결하는 방법**을 발견했을때 사용

## 나의 생각

- 좀,, 자바스크립트 특성이랑 밀접하게 관련된 설명들이 있는거 같다?!
- 너무 글이 안읽혀서 예시에 나와 있는 코드부터 보고 다시 설명을 보는게 훨씬 나았음

## 논의해볼 사항

- "7-1. 레코드 캡슐화 하기"에서 단순한 레코드는 계산해서 얻을 수 있는 값과, 그렇지 않은 값을 명확히 구분해 저장해야하는 점이 번거롭다고(?) 함. 이 때문에 가변 데이터를 저장하는 용도로는 레코드 보다 객체를 선호한다고 하는데,,, 사실 무슨 의미인지 모르겠음. 대체 어떤 배경에서 등장한거란 말임?

- "7-4. 임시 변수를 질의 함수로 바꾸기"에서 이 정도를 왜 함수로 바꿔야하는지 잘 모르겠음

  ```javascript
  // 전
  const basePrice = this._quantity * this._itemPrice;
  
  // 후
  get bssePrice() { this._quantity * this._itemPrice; }
  ```

  또한 긴 함수의 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면, 추출한 함수에 변수를 따로 전달할 필요가 없어지기 때문에 일이 수월해진다는 말도 무슨 뜻인지 모르겠음

- "7-6. 클래스 인라인하기" 에서 클래스에 **남은 역할이 거의 없을때,** 해당 클래스를 가장 많이 사용하는 클래스로 **흡수**시키라는데, "7-3. 기본형을 객체로 바꾸기"에서는 단순히 **출력 이상의 기능**이 필요해지는 순간 그 데이터를 표현하는 **전용 클래스** 정의하라고??? 정확히 반대되는 말 아님? 어쩌라는거임?

  
