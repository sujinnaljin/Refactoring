# Refactoring
매주 수요일 밤 아홉시! [왜웅](https://github.com/sovovy)과 함께하는 리팩토링 2판 스터디! 

![image](https://user-images.githubusercontent.com/20410193/152670400-d659eb02-e631-43f3-9705-c89b24c6b87b.png)

이번에는 과연,, 다 읽을 수 있을까!!

## 스터디 진행 방법

- 1- 4장은 책에서 꼼꼼히 보는걸 추천. 따라서 아래 내용들을 정리
  - 중요 내용
  - 개인적인 느낌, 생각
  - 서로 논의해볼 내용
  - 추가로 1, 4장에 나오는 예제 코드는 자신이 사용하는 언어로 실습

- 우선 4회차(-5장)까지 진행한 후 카탈로그 장 (6 - 12 장) 은 어떻게할지 얘기해보기 

## 일정

| 회차         | 내용                                                         |
| ------------ | ------------------------------------------------------------ |
| 1회차 (2/9)  | 1장 - 작은 프로그램 리팩토링 과정 <- 리팩토링이 뭔지 모르면 & 리팩토링을 하는 이유 |
| 2회차 (2/16) | 2장 - 리팩토링 원칙, 당위성 + 문제점 <- 리팩토링을 하는 이유 |
| 3회차 (2/23) | 3장 - 쓰레기 코드 찾는법, 리팩토링 방법 <- 리팩토링 해야할 곳을 찾을때 |
| 4회차 (3/2)  | 4장 - 테스트 작성법 & 5장 - 카탈로그 사용법                  |



# 1장
## 중요 내용
- 리팩토링 이전에 선행되어야 할 건 **테스트 코드**!  이게 있어야 코드를 수정해도 문제가 없나 파악할 수 있음
 
   `수정 -> 컴파일 -> 테스트` 가 하나의 사이클
- 코드가 길어지는 것 보다 **명확**하게 표현할 수 있는가가 더 중요. 
- 함수를 잘 **쪼개자**
- **다형성**을 잘 활용하자
- 변수 인라인하기 등의 기법 때문에 로직이 **여러번 호출**될 수 있음. 하지만 각종 **최적화** 기법 덕에 성능상 크게 차이가 없을 가능성이 많다고 함. 일단 리팩토링하고, 실제로 느려지면 그때 다시 수정,,하라고 함!
## 나의 생각
- 🤔 "변수 인라인하기"가 많이 나오는데, 그러면 같은 값을 여러 곳에서 관리해야해서 오히려 더 유지보수하기 불편해지지 않나? 한줄도 길어져서 가독성도 떨어지고,,? 이거는 좋은지 잘 모르겠다
  ![image](https://user-images.githubusercontent.com/20410193/152670034-8b32a6fb-0c17-4988-bbad-c2e5e9844f46.png)
## 해보면 좋을것
- 저자가 똑같은 동작의 for 문이라도 의미가 분리된다면 loop 를 분리하라고 했는데, 사실 이것도 읭? 스럽긴 함. 실제로 컴파일러에서 이걸 최적화 해서 묶어주나? 테스트해보면 좋을듯 -> [[Swift] Canonical SIL 까지의 최적화에 대한 고찰](https://sujinnaljin.medium.com/swift-canonical-sil-%EA%B9%8C%EC%A7%80%EC%9D%98-%EC%B5%9C%EC%A0%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-69fa2b0d5a4d)
```swift
//전
let range = (1...10)

var totalAmount = 0
var volumeCredits = 0
range.forEach { amount in
    totalAmount += amount
    volumeCredits += amount
}

//후
let range = (1...10)

var totalAmount = 0
range.forEach { amount in
    totalAmount += amount
}

var volumeCredits = 0
range.forEach { amount in
    volumeCredits += amount
}
```
# 2장

## 중요 내용

- **리팩터링**의 목적은 코드를 **이해**하고 **수정**하기 **쉽게** 만드는 것. **성능**은 좋아질 수도, **나빠질 수도** 있음

- 리팩토링하기 가장 좋은 **시점**은 코드 베이스에 **기능을 새로 추가하기 직전**. 이 시점에 현재 코드를 살펴보면서, **구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질만한 부분**을 찾음

- 리팩터링을 **하지 말아야**할 때

  - 지저분한 코드를 발견해도 굳이 **수정을 할 필요가 없**을때. **내부 동작을 이해해야할 시점**에 **리팩터링**해야 **효과**를 제대로 볼 수 있음
  - **처음부터 새로 작성**하는게 더 **쉬울** 때. 하지마 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때가 많기 때문에 이런 결정을 내리기 쉽지 않긴 함

- 리팩토링의 본질은 **경제적**인 것임. 즉 기능 추가 및 버그 수정 시간을 줄여 **개발 기간을 단축**하는 것. 단순히 클린 코드나 바람직한 엔지니어링 습관 정도가 아님

- 리팩토링시 고려할 문제

  - 브랜치

    - **머지** - **단방향** (ex. 마스터를 브랜치로 머지 -> 브랜치만 바뀌고 마스터는 그대로)
    - **통합** - **양방향** (ex. 마스터를 개인 브랜치로 가져와서 (pull) 작업한 결과를 다시 마스터에 올림 (push) -> 마스터와 브랜치 모두 변경)

    - **기능별 브랜치 방식**은 개인 브랜치에서 **전체 기능을 구현해 놓고 마스터 브랜치에 통합**하는 방식. 기능이 추가 될 때마다 **버전을 명확히 나눌**수 있고, 문제가 생기면 이전 상태로 **쉽게 되돌릴 수** 있음. 하지만 작업하는 **기간이 길어질**수록 마스터로 **통합하기 어려**워짐. 이를 해결하기 위해 마스터를 개인 브랜치로 **수시로 리베이스하거나 머지**함.
    - **다른 사람**들은 개인 브랜치에서 작업한 내용을 마스터에 **통합하기 전**까지는 그 **내용을 볼 수 없**음. 마스터에 통합이 된 이후에는 **달라진 내용을 내 브랜치에 머지**해야하는데 이때도 **상당한 노력**이 들 수 있음. 특히 **의미가 변한 부분**을 처리하기가 어려운데, 예를 들어 다른 브랜치에서 함수를 호출하는 코드를 추가했는데 내 브랜치에서는 그 함수의 이름을 변경했다고 하면 프로그램이 동작하지 않을 것. 이처럼 **머지가 복잡해지는 문제**는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어남. 

    - 이 때문에 **기능별 브랜치의 통합 주기를 짧게 관리**해야한다고 주장하는 사람들이 많음.이런 방식을 **지속적인 통합** (Continuous Integration - CI), 또는 **트렁크 개반 개발** (Trunk Based Development - TBD) 라고 함
    - **CI** 에 따르면 모든 팀원이 하루에 **최소 한번은 마스터와 통합**하는데, 이렇게 하면 **다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어**져서 **머지의 복잡도**를 상당히 **낮출 수** 있음. 
    - CI를 적용하기 위해서는 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용(기능 플래그)하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야함. 

    - **리팩터링**을 하다보면 코드 베이스 **전반에 걸쳐 자잘하게 수정**하는 부분이 많을 때가 있는데 (ex. 프로그램 전체에서 자주 사용하는 함수 이름 변경), 이때 **머지 과정에서 의미 충돌**이 생기기 쉬움. **기능별 브랜치 방식**에서는 리팩터링을 진행할 수 없을 정도로 **심각한 머지 문제**가 발생하기 쉬운데, **CI** 를 통해 이런 부분을 방지 가능

  - 테스트

    - 리팩터링을 위해서는 **자가 테스트 코드** (스스로 실패 / 성공 여부를 판단하는 코드) 가 필요
    - **자가 테스트 코드**는 **통합** 과정에서 발생하는 의미 **충돌을 잡는 메커니즘**으로 활용할 수 있어서 자연스럽게 **CI (지속적 통합) 와도 밀접하게 연**관 (자가 테스트 코드는 CI의 핵심 요소).  **CI에 통합된 테스트**는 **지속적인 배포 (Continuous Delivery) 의 핵심**이기도 함

- 앞으로 어느 부분에 유연성이 필요하고, 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 **추측하지 않고**, 현재까지 **파악한 요구 사항만을 해결**하는 소프트웨어를 구축 -> **YAGNI** (you aren't going to need it)

- **자가 테스트 코드, 지속적 통합, 리팩터링**이라는 세 기법은 서로 강력한 상승효과를 발휘 (XP 의 두드러진 특징은 이 기법들을 하나로 묶은 프로세스라는 점). 참고로 **자가 테스트 코드**와 **리팩터링**을 묶어 **테스트 주도 개발 (TDD)** 이라고 함

- 소프트웨어를 빠르게 만드는 비결은 먼저 **리팩터링을 통해 튜닝하기 쉽게 만들고** 나서, 원하는 속도가 나게끔 **튜닝**하는 것.
  - 리팩터링이 잘 되어있다면 **기능 추가가 빨리** 끝나서 **성능에 집중할 시간**을 더 벌수 있음
  - 리팩터링이 잘 되어있는 프로그램은 성능을 더 **세밀하게 분석**할 수 있음. 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고 그래서 **튜닝하기 쉬워짐**. 코드가 깔끔하면 개선안들이 더 잘 떠오를 것이고, 그 중 어떤 튜닝이 효과가 좋을지 파악하기 쉬움.
- **단기적**으로 보면 **리팩터링** 단계에서는 성능이 **느려**질 수도 있지만, **최적화** 단계에서 코드를 **튜닝하기 훨씬 쉬워**지기 때문에 결국 **더 빠른 소프트웨어**를 얻게 됨
- 따라서 저자는 실제로 소프트웨어를 **이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정**하는 경우가 많다고 함.
- 대부분 프로그램은 전체 코드 중 **극히 일부에서 대부분의 시간을 소비**함. 그래서 코드 전체를 **고르게 최적화** 한다면 그 중 90%는 효과가 거의 없기 때문에 **시간 낭비**인 셈. 또한 정작 컴파일러와 런타임과 하드웨어의 **동작을 제대로 이해하지 못한채 작성**해서 **효과를 얻지 못**할 때가 많음. 따라서 의도적으로 **성능 최적화에 돌입하기 전**까지는 성능에 신경을 쓰지 않고 **코드를 다루기 쉽게 만드**는데 집중.
- 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 **프로파일러 등을 통해 성능을 분석**해봐야 함
- **자동 리팩터링**에서 **정적 타입 언어**라면 훨씬 **안전**하게 구현할 수 있는 **리팩터링 수가 늘어**남. 예를 들어 두 클래스에 같은 이름의 함수가 있고 그 중 하나를 바꾸려는 경우에 정적 타입을 지원하지 않는다면 해당 메서드를 호출하는 모든 지점의 목록을 제공함. 우리는 목록을 일일이 살펴보면서 이름을 바꿀 대상을 직접 골라야함.

- **IDE** 는 **구문 트리를 분석**해서 리팩터링

## 나의 생각

- `테스트 코드가 없는 기능 리팩터링 -> 변경 사항에 대해 테스트를 해볼 수 없음 -> 이전과 같은 결과를 100% 보장하지 못함`. 요 플로우기 때문에 **기능 구현 전에 테스트 코드**를 만들어 놓는게 정말 정말 중요하구나
- 난 머지라는 용어만 써왔는데 이번에 **통합**이란 용어도 알게 됐다. **양방향**으로 영향 주는 것..! 지속적인 통합 할때 통합이 이 뜻이었군.
- 맨날 "CI / CD" 할때 **CI** 가 도대체 뭔가 했는데 **통합 주기 짧게** 가져가는걸 말하는거였군. 브랜치들간 **diff 가 크지 않아 머지가 쉽다**는 장점 ㅇㅋㅇㅋ
- GoF 의 디자인 패턴 할때 **GoF** 가 사람 이름이 아니라 **Gang of Four** 였다니 충격 ㅇ0ㅇ!







